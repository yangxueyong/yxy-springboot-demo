<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>大文件上传</title>
    <style>
        .progress {
            height: 20px;
            margin-bottom: 20px;
            overflow: hidden;
            background-color: #f5f5f5;
            border-radius: 4px;
            box-shadow: inset 0 1px 2px rgba(0,0,0,.1);
        }
        .progress-bar {
            float: left;
            width: 0;
            height: 100%;
            font-size: 12px;
            line-height: 20px;
            color: #fff;
            text-align: center;
            background-color: #337ab7;
            transition: width .6s ease;
        }
    </style>
</head>
<body>
<h1>大文件上传示例</h1>

<input type="file" id="fileInput">
<button id="uploadBtn">开始上传</button>
<button id="pauseBtn" disabled>暂停</button>
<button id="resumeBtn" disabled>继续</button>

<div class="progress">
    <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%;">
        0%
    </div>
</div>

<div id="status"></div>

<script src="spark-md5.min.js"></script>
<script>
    // 全局变量
    let file = null;
    let chunkSize = 2 * 1024 * 1024; // 2MB
    let totalChunks = 0;
    let uploadedChunks = 0;
    let uploadId = null;
    let isPaused = false;
    let fileIdentifier = null;

    // 获取元素
    const fileInput = document.getElementById('fileInput');
    const uploadBtn = document.getElementById('uploadBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const progressBar = document.getElementById('progressBar');
    const statusDiv = document.getElementById('status');

    // 事件监听
    fileInput.addEventListener('change', handleFileSelect);
    uploadBtn.addEventListener('click', startUpload);
    pauseBtn.addEventListener('click', pauseUpload);
    resumeBtn.addEventListener('click', resumeUpload);

    // 选择文件
    function handleFileSelect(e) {
        file = e.target.files[0];
        if (!file) return;

        statusDiv.innerHTML = '计算文件标识符...';

        // 计算文件MD5作为标识符
        calculateFileMD5(file).then(identifier => {
            fileIdentifier = identifier;
            totalChunks = Math.ceil(file.size / chunkSize);
            statusDiv.innerHTML = `文件准备就绪: ${file.name} (${formatFileSize(file.size)})`;
            uploadBtn.disabled = false;
        });
    }

    // 开始上传
    async function startUpload() {
        if (!file) return;

        uploadBtn.disabled = true;
        pauseBtn.disabled = false;
        statusDiv.innerHTML = '检查文件状态...';

        // 检查文件是否已存在（秒传）
        const checkResponse = await fetch('http://127.0.0.1:8080/upload/check', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: `identifier=${fileIdentifier}`
        });

        const checkResult = await checkResponse.json();
        if (checkResult.exist) {
            statusDiv.innerHTML = '文件已存在，秒传成功！';
            progressBar.style.width = '100%';
            progressBar.innerHTML = '100%';
            return;
        }

        // 开始上传分片
        uploadId = fileIdentifier;
        uploadedChunks = 0;
        isPaused = false;

        for (let i = 1; i <= totalChunks; i++) {
            if (isPaused) break;

            // 检查分片是否已上传
            const chunkCheckResponse = await fetch('http://127.0.0.1:8080/upload/chunkCheck', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `identifier=${fileIdentifier}&chunkNumber=${i}`
            });

            const chunkCheckResult = await chunkCheckResponse.json();
            if (chunkCheckResult.exist) {
                uploadedChunks++;
                updateProgress();
                continue;
            }

            // 上传分片
            const start = (i - 1) * chunkSize;
            const end = Math.min(start + chunkSize, file.size);
            const chunk = file.slice(start, end);

            const formData = new FormData();
            formData.append('file', chunk);
            formData.append('id', fileIdentifier);
            formData.append('uploadId', fileIdentifier);
            formData.append('chunkNumber', i);
            formData.append('chunkSize', chunkSize);
            formData.append('currentChunkSize', chunk.size);
            formData.append('totalSize', file.size);
            formData.append('identifier', fileIdentifier);
            formData.append('filename', file.name);
            formData.append('relativePath', file.webkitRelativePath || '');
            formData.append('totalChunks', totalChunks);
            formData.append('type', file.type);

            try {
                const response = await fetch('http://127.0.0.1:8080/upload/chunk', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                if (result.success) {
                    uploadedChunks++;
                    updateProgress();
                } else {
                    statusDiv.innerHTML = `分片 ${i} 上传失败: ${result.message}`;
                    break;
                }
            } catch (error) {
                statusDiv.innerHTML = `分片 ${i} 上传失败: ${error.message}`;
                break;
            }
        }

        if (uploadedChunks === totalChunks) {
            // 所有分片上传完成，合并文件
            statusDiv.innerHTML = '正在合并文件...';

            const mergeResponse = await fetch('http://127.0.0.1:8080/upload/merge', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    identifier: fileIdentifier,
                    filename: file.name,
                    totalSize: file.size,
                    totalChunks: totalChunks,
                    chunkSize: chunkSize
                })
            });

            const mergeResult = await mergeResponse.json();
            if (mergeResult.success) {
                statusDiv.innerHTML = `文件上传成功！路径: ${mergeResult.filePath}`;
            } else {
                statusDiv.innerHTML = `文件合并失败: ${mergeResult.message}`;
            }

            pauseBtn.disabled = true;
            resumeBtn.disabled = true;
        }
    }

    // 暂停上传
    function pauseUpload() {
        isPaused = true;
        pauseBtn.disabled = true;
        resumeBtn.disabled = false;
        statusDiv.innerHTML = '上传已暂停';
    }

    // 继续上传
    function resumeUpload() {
        isPaused = false;
        pauseBtn.disabled = false;
        resumeBtn.disabled = true;
        statusDiv.innerHTML = '继续上传...';
        startUpload();
    }

    // 更新进度条
    function updateProgress() {
        const progress = (uploadedChunks / totalChunks) * 100;
        progressBar.style.width = `${progress}%`;
        progressBar.innerHTML = `${progress.toFixed(2)}%`;
    }

    // 计算文件MD5
    function calculateFileMD5(file) {
        return new Promise((resolve, reject) => {
            const chunkSize = 2 * 1024 * 1024; // 2MB
            const chunks = Math.ceil(file.size / chunkSize);
            let currentChunk = 0;
            const spark = new SparkMD5.ArrayBuffer();
            const fileReader = new FileReader();

            fileReader.onload = function(e) {
                spark.append(e.target.result);
                currentChunk++;

                if (currentChunk < chunks) {
                    loadNext();
                } else {
                    resolve(spark.end());
                }
            };

            fileReader.onerror = function() {
                reject(new Error('文件读取失败'));
            };

            function loadNext() {
                const start = currentChunk * chunkSize;
                const end = Math.min(start + chunkSize, file.size);
                fileReader.readAsArrayBuffer(file.slice(start, end));
            }

            loadNext();
        });
    }

    // 格式化文件大小
    function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        else if (bytes < 1048576) return (bytes / 1024).toFixed(2) + ' KB';
        else if (bytes < 1073741824) return (bytes / 1048576).toFixed(2) + ' MB';
        else return (bytes / 1073741824).toFixed(2) + ' GB';
    }
</script>
</body>
</html>